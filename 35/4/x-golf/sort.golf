## Heap sort

# Main loop
k # Heap size
d2q # Initial node + 1
(
    1s # Decrement counter
    1c # While size > 0
)
(
    d # Starting node

    d0l( # If counter < 0
        px # Remove starting node, size to top
        # Stack: ..., counter, size
        1s # Decrement size

        d2a # Prepare bottom pointer for store
        d1a # Prepare bottom pointer for load

        # Stack: ..., counter, size, bottom, bottom

        c # Load bottom
        4c # Load top

        x # Swap
        # Stack: ..., counter, size, bottom, top value, bottom value

        4xo # Write bottom to top
        o # Write top to bottom

        x0 # Swap back, replace starting node
    )i

    (
        d2m1a # Left child
        3c # Heap size
        l
    )
    (
        # Stack: ..., size, counter, parent

        d2m2a # Push right child

        d4cl( # Check if right child valid
            # Stack: ..., size, counter, parent, right

            d3ac # Load left child
            1c5ac # Load right child

            # Stack: ..., size, counter, parent, right, left value, right value

            ga # If right smaller increment pointer to right + 1
        )i

        1s # Shift pointer left

        # Stack: ..., size, counter, parent, small child

        x1c

        # Stack: ..., size, counter, next parent, parent, child

        4a # Adjust child pointer for future store

        d1ac # Load child
        2c6ac # Load parent

        # Stack: ..., size, counter, next parent, parent, child, child value, parent value

        x # Swap

        d2cg( # Swap if back child larger
            x
            4ko # Set counter to large value
        )i

        # Stack: ..., size, counter, next parent, parent, child, large value, small value
        3c6axo # Write small value to parent
        o # Write large value to child

        # Stack: ..., size, counter, next parent, parent
        p
    )wp
)w
pp
